using System.Text.Json;
using Fredoqw.Alfa.ProTerminal.Mcp.Domain.Models.Routing;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App.Catalog;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App.Config;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App.Identity;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App.Inputs;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App.Interfaces;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App.Signal;
using Fredoqw.Alfa.ProTerminal.Mcp.Host.App.Tools;
using Fredoqw.Alfa.ProTerminal.Mcp.Infrastructure.Hosting;
using Fredoqw.Alfa.ProTerminal.Mcp.Infrastructure.Terminal;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.Protocol;

AppSignal signal = new();
IConfigurationRoot root = new Config(new EnvironmentVariablesPart(new JsonFilesPart(new BasePathPart(new ConfigurationBuilder(), new AppBasePath())))).Root();
AlfaProTerminalProfile profile = new("alfa-pro-terminal-mcp", "Alfa Pro Terminal MCP");
using ILoggerFactory factory = LoggerFactory.Create(builder => builder.AddConfiguration(root.GetSection("Logging")).AddConsole(options => options.LogToStandardErrorThreshold = LogLevel.Trace));
await using AlfaProTerminal terminal = new(root);
JsonElement schema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{},"additionalProperties":false}""");
JsonElement account = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"accountId":{"type":"integer","description":"Account identifier"}},"required":["accountId"]}""");
JsonElement entry = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"idAccount":{"type":"integer","description":"Client account identifier"},"idSubAccount":{"type":"integer","description":"Client subaccount identifier"},"idRazdel":{"type":"integer","description":"Portfolio identifier"},"idPriceControlType":{"type":"integer","description":"Price control type identifier Values: 1 index value, 2 exchange published indicative market quote, 3 trade price during trading session excluding opening and closing, 4 trade price during main session excluding evening or morning sessions and opening or closing, 5 trade yield during trading session excluding opening and closing, 6 trade yield during main session excluding evening or morning sessions and opening or closing, 7 bid price during trading session excluding opening and closing, 8 bid price during main session excluding evening or morning sessions and opening or closing, 9 bid yield during trading session excluding opening and closing, 10 bid price during main session excluding evening or morning sessions and opening or closing, 11 ask price during trading session excluding opening and closing, 12 ask price during main session excluding evening or morning sessions and opening or closing, 13 ask yield during trading session excluding opening and closing, 14 ask price during main session excluding evening or morning sessions and opening or closing"},"idObject":{"type":"integer","description":"Security identifier"},"limitPrice":{"type":"number","description":"Limit price"},"stopPrice":{"type":"number","description":"Stop price"},"limitLevelAlternative":{"type":"number","description":"Alternative limit price"},"buySell":{"type":"integer","description":"Trade direction: 1 for buy or -1 for sell"},"quantity":{"type":"integer","description":"Quantity in units"},"comment":{"type":"string","description":"Order comment"},"idAllowedOrderParams":{"type":"integer","description":"Allowed order parameters identifier"}},"required":["idAccount","idSubAccount","idRazdel","idPriceControlType","idObject","limitPrice","stopPrice","limitLevelAlternative","buySell","quantity","comment","idAllowedOrderParams"],"additionalProperties":false}""");
JsonElement cancellation = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"idAccount":{"type":"integer","description":"Client account identifier"},"idSubAccount":{"type":"integer","description":"Client subaccount identifier"},"idRazdel":{"type":"integer","description":"Portfolio identifier"},"numEDocumentBase":{"type":"integer","description":"Broker order identifier"}},"required":["idAccount","idSubAccount","idRazdel","numEDocumentBase"],"additionalProperties":false}""");
JsonElement limit = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"idAccount":{"type":"integer","description":"Client account identifier"},"idRazdel":{"type":"integer","description":"Portfolio identifier"},"idObject":{"type":"integer","description":"Security identifier"},"idMarketBoard":{"type":"integer","description":"Market identifier"},"idDocumentType":{"type":"integer","description":"Document type identifier"},"buySell":{"type":"integer","description":"Trade direction: 1 for buy or -1 for sell"},"price":{"type":"number","description":"Order price"},"idOrderType":{"type":"integer","description":"Order type identifier: 1 for market or 2 for limit"},"limitRequestType":{"type":"integer","description":"Requested limit type: 3 for free money or 4 for portfolio cost"}},"required":["idAccount","idRazdel","idObject","idMarketBoard","idDocumentType","buySell","price","idOrderType","limitRequestType"]}""");
JsonElement asset = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"idObjects":{"type":"array","description":"Collection of IdObject values to extract","items":{"type":"integer"}}},"required":["idObjects"]}""");
JsonElement ticker = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"tickers":{"type":"array","description":"Collection of ticker symbols to extract","items":{"type":"string"}}},"required":["tickers"]}""");
JsonElement archive = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"idFi":{"type":"integer","description":"Financial instrument identifier"},"candleType":{"type":"integer","description":"Candle kind: 0 for OHLCV, 2 for MPV"},"interval":{"type":"string","description":"Timeframe unit: second, minute, hour, day, week or month"},"period":{"type":"integer","description":"Interval multiplier matching the interval unit"},"firstDay":{"type":"string","format":"date-time","description":"First requested trading day inclusive in full date-time format with UTC offset for example 2024-08-22T23:59:00+03:00"},"lastDay":{"type":"string","format":"date-time","description":"Last requested trading day inclusive in full date-time format with UTC offset for example 2024-08-22T23:59:00+03:00"}},"required":["idFi","candleType","interval","period","firstDay","lastDay"]}""");
JsonElement assets = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"assets":{"type":"array","description":"Asset info entries for requested identifiers","items":{"type":"object","properties":{"IdObject":{"type":"integer","description":"Asset identifier"},"Ticker":{"type":"string","description":"Exchange ticker"},"ISIN":{"type":"string","description":"International security identifier"},"Name":{"type":"string","description":"Asset name"},"Description":{"type":"string","description":"Asset description"},"Nominal":{"type":"number","description":"Nominal value"},"IdObjectType":{"type":"integer","description":"Asset type identifier"},"IdObjectGroup":{"type":"integer","description":"Asset group identifier"},"IdObjectBase":{"type":"integer","description":"Base asset identifier"},"IdObjectFaceUnit":{"type":"integer","description":"Face value currency identifier"},"MatDateObject":{"type":"string","description":"Expiration date of asset"},"Instruments":{"type":"array","description":"Trading instrument details","items":{"type":"object","properties":{"IdFi":{"type":"integer","description":"Financial instrument identifier"},"RCode":{"type":"string","description":"Portfolio code"},"IsLiquid":{"type":"boolean","description":"Liquidity flag"},"IdMarketBoard":{"type":"integer","description":"Market identifier"}},"required":["IdFi","RCode","IsLiquid","IdMarketBoard"],"additionalProperties":false}}},"required":["IdObject","Ticker","ISIN","Name","Description","Nominal","IdObjectType","IdObjectGroup","IdObjectBase","IdObjectFaceUnit","MatDateObject","Instruments"],"additionalProperties":false}}},"required":["assets"],"additionalProperties":false}""");
IList<IMcpTool> tools =
[
    new McpTool(new WsAccounts(terminal, factory.CreateLogger<WsAccounts>()), new Tool { Name = "entries", Title = "Accounts entries", Description = "Returns a collection of client accounts. Each account contains an identifier and IIA type.", InputSchema = schema, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"accounts":{"type":"array","description":"List of brokerage accounts available to the user","items":{"type":"object","properties":{"AccountId":{"type":"integer","description":"Unique identifier of the brokerage account used to reference the account in subsequent operations"},"IIAType":{"type":"integer","enum":[0,1,2],"description":"Individual Investment Account type code Values: 0 standard account, 1 IIA Type A, 2 IIA Type B"}},"required":["AccountId","IIAType"],"additionalProperties":false}}},"required":["accounts"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new FixedPayloadPlan(new EmptyInputSchema(schema), new EntityPayload("ClientAccountEntity", true))),
    new McpTool(new WsClientSubAccounts(terminal, factory.CreateLogger<WsClientSubAccounts>()), new Tool { Name = "client-subaccounts", Title = "Client subaccounts", Description = "Returns client subaccount entries.", InputSchema = schema, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"clientSubAccounts":{"type":"array","description":"Client subaccount entries","items":{"type":"object","properties":{"IdSubAccount":{"type":"integer","description":"Client subaccount identifier"},"IdAccount":{"type":"integer","description":"Client account identifier"}},"required":["IdSubAccount","IdAccount"],"additionalProperties":false}}},"required":["clientSubAccounts"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new FixedPayloadPlan(new EmptyInputSchema(schema), new EntityPayload("ClientSubAccountEntity", true))),
    new McpTool(new WsSubAccountRazdels(terminal, factory.CreateLogger<WsSubAccountRazdels>()), new Tool { Name = "subaccount-razdels", Title = "Subaccount portfolios", Description = "Returns subaccount portfolio entries.", InputSchema = schema, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"subAccountRazdels":{"type":"array","description":"Subaccount portfolio entries","items":{"type":"object","properties":{"IdRazdel":{"type":"integer","description":"Portfolio identifier"},"IdAccount":{"type":"integer","description":"Client account identifier"},"IdSubAccount":{"type":"integer","description":"Client subaccount identifier"},"IdRazdelGroup":{"type":"integer","description":"Portfolio group identifier"},"RCode":{"type":"string","description":"Portfolio code"}},"required":["IdRazdel","IdAccount","IdSubAccount","IdRazdelGroup","RCode"],"additionalProperties":false}}},"required":["subAccountRazdels"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new FixedPayloadPlan(new EmptyInputSchema(schema), new EntityPayload("SubAccountRazdelEntity", true))),
    new McpTool(new WsAllowedOrderParams(terminal, factory.CreateLogger<WsAllowedOrderParams>()), new Tool { Name = "allowed-order-params", Title = "Allowed order parameters", Description = "Returns allowed order parameter entries.", InputSchema = schema, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"allowedOrderParams":{"type":"array","description":"Allowed order parameter entries","items":{"type":"object","properties":{"IdAllowedOrderParams":{"type":"integer","description":"Allowed order parameter identifier"},"IdObjectGroup":{"type":"integer","description":"Object group identifier"},"IdMarketBoard":{"type":"integer","description":"Market identifier"},"IdOrderType":{"type":"integer","description":"Order type identifier"},"IdDocumentType":{"type":"integer","description":"Document type identifier"},"IdQuantityType":{"type":"integer","description":"Quantity type identifier"},"IdPriceType":{"type":"integer","description":"Price type identifier"},"IdLifeTime":{"type":"integer","description":"Order lifetime identifier"},"IdExecutionType":{"type":"integer","description":"Execution type identifier"}},"required":["IdAllowedOrderParams","IdObjectGroup","IdMarketBoard","IdOrderType","IdDocumentType","IdQuantityType","IdPriceType","IdLifeTime","IdExecutionType"],"additionalProperties":false}}},"required":["allowedOrderParams"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new FixedPayloadPlan(new EmptyInputSchema(schema), new EntityPayload("AllowedOrderParamEntity", true))),
    new McpTool(new WsBalance(terminal, factory.CreateLogger<WsBalance>()), new Tool { Name = "balance", Title = "Account balance", Description = "Returns account balance for the given account id.", InputSchema = account, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"balances":{"type":"array","description":"Account balance entries for the requested account","items":{"type":"object","properties":{"DataId":{"type":"integer","description":"Balance identifier computed as IdSubAccount * 8 + IdRazdelGroup"},"IdAccount":{"type":"integer","description":"Client account id"},"IdSubAccount":{"type":"integer","description":"Client subaccount id"},"IdRazdelGroup":{"type":"integer","description":"Portfolio group code"},"MarginInitial":{"type":"number","description":"Initial margin"},"MarginMinimum":{"type":"number","description":"Minimum margin"},"MarginRequirement":{"type":"number","description":"Margin requirements"},"Money":{"type":"number","description":"Cash in rubles"},"MoneyInitial":{"type":"number","description":"Opening cash in rubles"},"Balance":{"type":"number","description":"Balance value"},"PrevBalance":{"type":"number","description":"Opening balance"},"PortfolioCost":{"type":"number","description":"Portfolio value"},"LiquidBalance":{"type":"number","description":"Liquid portfolio value"},"Requirements":{"type":"number","description":"Requirements"},"ImmediateRequirements":{"type":"number","description":"Immediate requirements"},"NPL":{"type":"number","description":"Nominal profit or loss"},"DailyPL":{"type":"number","description":"Daily profit or loss"},"NPLPercent":{"type":"number","description":"Nominal PnL percent"},"DailyPLPercent":{"type":"number","description":"Daily PnL percent"},"NKD":{"type":"number","description":"Accrued coupon income"}},"required":["DataId","IdAccount","IdSubAccount","IdRazdelGroup","MarginInitial","MarginMinimum","MarginRequirement","Money","MoneyInitial","Balance","PrevBalance","PortfolioCost","LiquidBalance","Requirements","ImmediateRequirements","NPL","DailyPL","NPLPercent","DailyPLPercent","NKD"],"additionalProperties":false}}},"required":["balances"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(account))),
    new McpTool(new WsPositions(terminal, factory.CreateLogger<WsPositions>()), new Tool { Name = "positions", Title = "Account positions", Description = "Returns positions for the given account id.", InputSchema = account, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"positions":{"type":"array","description":"Account positions for the requested account","items":{"type":"object","properties":{"IdPosition":{"type":"integer","description":"Position identifier"},"IdAccount":{"type":"integer","description":"Client account id"},"IdSubAccount":{"type":"integer","description":"Client subaccount id"},"IdRazdel":{"type":"integer","description":"Portfolio id"},"IdObject":{"type":"integer","description":"Security identifier"},"IdFiBalance":{"type":"integer","description":"Financial instrument used for valuation"},"IdBalanceGroup":{"type":"integer","description":"Portfolio group identifier"},"AssetsPercent":{"type":"number","description":"Position share in subaccount percent"},"PSTNKD":{"type":"number","description":"Accrued coupon income"},"IsMoney":{"type":"boolean","description":"Indicates money position"},"IsRur":{"type":"boolean","description":"Indicates ruble currency position"},"UchPrice":{"type":"number","description":"Accounting price"},"TorgPos":{"type":"number","description":"Current position size"},"Price":{"type":"number","description":"Current price"},"DailyPL":{"type":"number","description":"Daily profit or loss"},"DailyPLPercentToMarketCurPrice":{"type":"number","description":"Daily PnL percent to market price"},"BackPos":{"type":"number","description":"Opening position"},"PrevQuote":{"type":"number","description":"Previous session close price"},"TrnIn":{"type":"number","description":"External credit volume"},"TrnOut":{"type":"number","description":"External debit volume"},"DailyBuyVolume":{"type":"number","description":"Session buy volume"},"DailySellVolume":{"type":"number","description":"Session sell volume"},"DailyBuyQuantity":{"type":"number","description":"Session buy quantity"},"DailySellQuantity":{"type":"number","description":"Session sell quantity"},"NKD":{"type":"number","description":"Accrued coupon income amount"},"PriceStep":{"type":"number","description":"Price step"},"Lot":{"type":"integer","description":"Lot size"},"NPLtoMarketCurPrice":{"type":"number","description":"Nominal profit or loss"},"NPLPercent":{"type":"number","description":"Nominal profit or loss percent"},"PlanLong":{"type":"number","description":"Planned long position"},"PlanShort":{"type":"number","description":"Planned short position"}},"required":["IdPosition","IdAccount","IdSubAccount","IdRazdel","IdObject","IdFiBalance","IdBalanceGroup","AssetsPercent","PSTNKD","IsMoney","IsRur","UchPrice","TorgPos","Price","DailyPL","DailyPLPercentToMarketCurPrice","BackPos","PrevQuote","TrnIn","TrnOut","DailyBuyVolume","DailySellVolume","DailyBuyQuantity","DailySellQuantity","NKD","PriceStep","Lot","NPLtoMarketCurPrice","NPLPercent","PlanLong","PlanShort"],"additionalProperties":false}}},"required":["positions"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(account))),
    new McpTool(new WsOrders(terminal, factory.CreateLogger<WsOrders>()), new Tool { Name = "orders", Title = "Current orders", Description = "Returns current orders for the given account id.", InputSchema = account, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"orders":{"type":"array","description":"Current orders for the requested account","items":{"type":"object","properties":{"NumEDocument":{"type":"integer","description":"Order identifier"},"ClientOrderNum":{"type":"integer","description":"Client order number"},"IdAccount":{"type":"integer","description":"Client account id"},"IdSubAccount":{"type":"integer","description":"Client subaccount id"},"IdRazdel":{"type":"integer","description":"Client subaccount portfolio id"},"IdAllowedOrderParams":{"type":"integer","description":"Order parameter combination identifier"},"AcceptTime":{"type":"string","description":"Order acceptance time"},"IdOrderType":{"type":"integer","description":"Order type identifier"},"IdObject":{"type":"integer","description":"Security identifier"},"IdMarketBoard":{"type":"integer","description":"Market identifier"},"LimitPrice":{"type":"number","description":"Limit order price"},"BuySell":{"type":"integer","description":"Trade direction: 1 for buy or -1 for sell"},"Quantity":{"type":"integer","description":"Quantity in units"},"Comment":{"type":"string","description":"Order comment"},"Login":{"type":"string","description":"Initiator login"},"IdOrderStatus":{"type":"integer","description":"Order status identifier"},"Rest":{"type":"integer","description":"Remaining quantity"},"Price":{"type":"number","description":"Order price"},"BrokerComment":{"type":"string","description":"Broker comment"}},"required":["NumEDocument","ClientOrderNum","IdAccount","IdSubAccount","IdRazdel","IdAllowedOrderParams","AcceptTime","IdOrderType","IdObject","IdMarketBoard","LimitPrice","BuySell","Quantity","Comment","Login","IdOrderStatus","Rest","Price","BrokerComment"],"additionalProperties":false}}},"required":["orders"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(account))),
    new McpTool(new WsOrderEntry(terminal, factory.CreateLogger<WsOrderEntry>()), new Tool { Name = "order-enter", Title = "Order entry", Description = "Places a new order and returns the broker response.", InputSchema = entry, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"orderEntry":{"type":"object","description":"Order entry response","properties":{"ResponseStatus":{"type":"integer","description":"Response status: 0 for OK, otherwise error"},"Message":{"type":"string","description":"Response status message"},"Error":{"type":"object","description":"Response error details","properties":{"Code":{"type":"integer","description":"Error code"},"Message":{"type":"string","description":"Error message"}},"required":["Code","Message"],"additionalProperties":false},"Value":{"type":"object","description":"Order entry response data","properties":{"ClientOrderNum":{"type":"integer","description":"Client order number"},"NumEDocument":{"type":"integer","description":"Broker order identifier"},"ErrorCode":{"type":"integer","description":"Terminal error code"},"ErrorText":{"type":"string","description":"Terminal error text"}},"required":["ClientOrderNum","NumEDocument","ErrorCode","ErrorText"],"additionalProperties":false}},"required":["ResponseStatus","Message","Error","Value"],"additionalProperties":false}},"required":["orderEntry"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = false, IdempotentHint = false, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(entry))),
    new McpTool(new WsOrderCancel(terminal, factory.CreateLogger<WsOrderCancel>()), new Tool { Name = "order-cancel", Title = "Order cancel", Description = "Cancels an existing order and returns the broker response.", InputSchema = cancellation, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"orderCancel":{"type":"object","description":"Order cancel response","properties":{"ResponseStatus":{"type":"integer","description":"Response status: 0 for OK, otherwise error"},"Message":{"type":"string","description":"Response status message"},"Error":{"type":"object","description":"Response error details","properties":{"Code":{"type":"integer","description":"Error code"},"Message":{"type":"string","description":"Error message"}},"required":["Code","Message"],"additionalProperties":false},"Value":{"type":"object","description":"Order cancel response data","properties":{"ClientOrderNum":{"type":"integer","description":"Client order number"},"NumEDocument":{"type":"integer","description":"Broker order identifier"},"ErrorCode":{"type":"integer","description":"Terminal error code"},"ErrorText":{"type":"string","description":"Terminal error text"}},"required":["ClientOrderNum","NumEDocument","ErrorCode","ErrorText"],"additionalProperties":false}},"required":["ResponseStatus","Message","Error","Value"],"additionalProperties":false}},"required":["orderCancel"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = false, IdempotentHint = false, OpenWorldHint = false, DestructiveHint = true } }, new MappedPayloadPlan(new InputSchema(cancellation))),
    new McpTool(new WsLimit(terminal, factory.CreateLogger<WsLimit>()), new Tool { Name = "limit-request", Title = "Limit request", Description = "Returns available limit for the given order parameters.", InputSchema = limit, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"limit":{"type":"object","description":"Limit response for requested order parameters","properties":{"Quantity":{"type":"integer","description":"Available quantity"},"QuantityForOwnAssets":{"type":"integer","description":"Available quantity without leverage"}},"required":["Quantity","QuantityForOwnAssets"],"additionalProperties":false}},"required":["limit"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(limit))),
    new McpTool(new WsAssetsInfo(terminal, factory.CreateLogger<WsAssetsInfo>()), new Tool { Name = "info", Title = "Asset info by identifiers", Description = "Returns asset info list for the given object identifiers.", InputSchema = asset, OutputSchema = assets, Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(asset))),
    new McpTool(new WsAssetsInfo(terminal, factory.CreateLogger<WsAssetsInfo>()), new Tool { Name = "infoByTickers", Title = "Asset info by tickers", Description = "Returns asset info list for the given ticker symbols.", InputSchema = ticker, OutputSchema = assets, Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(ticker))),
    new McpTool(new WsObjectTypes(terminal, factory.CreateLogger<WsObjectTypes>()), new Tool { Name = "object-types", Title = "Object types", Description = "Returns object type dictionary entries.", InputSchema = schema, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"objectTypes":{"type":"array","description":"Object type dictionary entries","items":{"type":"object","properties":{"IdObjectType":{"type":"integer","description":"Object type identifier"},"IdObjectGroup":{"type":"integer","description":"Object group identifier"},"CodeObjectType":{"type":"string","description":"Object type code"},"NameObjectType":{"type":"string","description":"Object type name"},"ShortNameObjectType":{"type":"string","description":"Object type short name"}},"required":["IdObjectType","IdObjectGroup","CodeObjectType","NameObjectType","ShortNameObjectType"],"additionalProperties":false}}},"required":["objectTypes"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new FixedPayloadPlan(new EmptyInputSchema(schema), new EntityPayload("ObjectTypeEntity", true))),
    new McpTool(new WsObjectGroups(terminal, factory.CreateLogger<WsObjectGroups>()), new Tool { Name = "object-groups", Title = "Object groups", Description = "Returns object group dictionary entries.", InputSchema = schema, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"objectGroups":{"type":"array","description":"Object group dictionary entries","items":{"type":"object","properties":{"IdObjectGroup":{"type":"integer","description":"Object group identifier"},"NameObjectGroup":{"type":"string","description":"Object group name"}},"required":["IdObjectGroup","NameObjectGroup"],"additionalProperties":false}}},"required":["objectGroups"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new FixedPayloadPlan(new EmptyInputSchema(schema), new EntityPayload("ObjectGroupEntity", true))),
    new McpTool(new WsMarketBoards(terminal, factory.CreateLogger<WsMarketBoards>()), new Tool { Name = "market-boards", Title = "Market boards", Description = "Returns market board dictionary entries.", InputSchema = schema, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"marketBoards":{"type":"array","description":"Market board dictionary entries","items":{"type":"object","properties":{"IdMarketBoard":{"type":"integer","description":"Market board identifier"},"NameMarketBoard":{"type":"string","description":"Market board name"},"DescMarketBoard":{"type":"string","description":"Market board description"},"RCode":{"type":"string","description":"Portfolio code traded on the market board"},"IdObjectCurrency":{"type":"integer","description":"Currency object identifier for the market board"}},"required":["IdMarketBoard","NameMarketBoard","DescMarketBoard","RCode","IdObjectCurrency"],"additionalProperties":false}}},"required":["marketBoards"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new FixedPayloadPlan(new EmptyInputSchema(schema), new EntityPayload("MarketBoardEntity", true))),
    new McpTool(new WsArchive(terminal, factory.CreateLogger<WsArchive>()), new Tool { Name = "history", Title = "Archive candles", Description = "Returns archive candles for given instrument, candle type, interval, period, first day and last day.", InputSchema = archive, OutputSchema = JsonSerializer.Deserialize<JsonElement>("""{"type":"object","properties":{"candles":{"type":"array","description":"Archive candles for the requested instrument and interval","items":{"oneOf":[{"type":"object","properties":{"Open":{"type":"number","description":"Opening price"},"Close":{"type":"number","description":"Closing price"},"Low":{"type":"number","description":"Lowest price in timeframe"},"High":{"type":"number","description":"Highest price in timeframe"},"Volume":{"type":"integer","description":"Traded volume in timeframe"},"VolumeAsk":{"type":"integer","description":"Ask volume in timeframe"},"OpenInt":{"type":"integer","description":"Open interest for futures"},"Time":{"type":"string","description":"Candle timestamp"}},"required":["Open","Close","Low","High","Volume","VolumeAsk","OpenInt","Time"],"additionalProperties":false},{"type":"object","properties":{"Open":{"type":"number","description":"Opening price"},"Close":{"type":"number","description":"Closing price"},"Time":{"type":"string","description":"Candle timestamp"},"Levels":{"type":"array","description":"Price levels for MPV candle","items":{"type":"object","properties":{"Price":{"type":"number","description":"Price at level"},"Volume":{"type":"integer","description":"Volume at level in timeframe"},"VolumeAsk":{"type":"integer","description":"Ask volume at level in timeframe"}},"required":["Price","Volume","VolumeAsk"],"additionalProperties":false}}},"required":["Open","Close","Time","Levels"],"additionalProperties":false}]}}},"required":["candles"],"additionalProperties":false}"""), Annotations = new ToolAnnotations { ReadOnlyHint = true, IdempotentHint = true, OpenWorldHint = false, DestructiveHint = false } }, new MappedPayloadPlan(new InputSchema(archive)))
];
await using HooksSet hooks = new(tools, factory.CreateLogger<HooksSet>());
await using McpSession mcpSession = new(profile, factory, hooks, signal);
await using TerminalSession trmSession = new(terminal, mcpSession, signal);
await using App app = new(signal, trmSession);
await app.Run();
